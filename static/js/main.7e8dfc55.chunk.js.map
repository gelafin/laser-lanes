{"version":3,"sources":["Game.js","reportWebVitals.js","index.js"],"names":["randomInt","min","max","Math","floor","random","Ship","props","enemyImgUrl","allyImgUrl","isAlly","isAlive","className","src","Laser","laserState","state","imageSource","ShipRow","shipRow","Object","values","ships","map","ship","getState","getId","OutputArea","outputString","output","outputChars","Array","from","idGenerator","reactKeys","outputCharPs","char","index","column","next","value","outputCharKeys","InputArea","handleChange","bind","event","this","onInputChange","target","type","input","onChange","React","Component","ShipObject","laneNumber","alive","lane","ally","idPrefix","id","toString","console","log","getLane","Game","maxColumns","allLanes","keys","tickMs","laserFireMs","isAtGameEnd","getInitialState","handleInputChange","tick","advanceShipState","fireAllChargingShips","getLetterInLane","projectLaserTarget","laneToId","destroyShip","getOppositeShip","fireLaser","haltLaser","checkEndGame","reinitializeState","replayPrompt","initialAllyShips","initialEnemyShips","newAlly","newEnemy","initialAllyShipStates","firingShips","chargingShips","idleShips","initialEnemyShipStates","allyShips","enemyShips","allyShipStates","enemyShipStates","setState","shipId","laneStateArray","shipObjects","includes","newStateGroup","oldStateGroup","shipState","newShipObjects","advanceState","removalIndex","indexOf","newStateGroupArray","oldStateGroupArray","push","splice","length","oppositeShipId","oppositeGroup","letter","toLowerCase","oppositeShip","resultMessage","endGameCondition","clearInterval","timerID","prompt","window","location","sfx","explosion","play","catch","destroy","shipObject","disabledLaser","firingLaser","setTimeout","retire","allyId","enemyId","allyShip","enemyShip","allyCount","enemyCount","randomIdleAllyIndex","randomIdleEnemyIndex","randomIdleAllyId","randomIdleEnemyId","chargingLaser","alert","setInterval","Audio","volume","MAX_COLUMNS","fill","element","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.7e8dfc55.chunk.js","sourcesContent":["import React from 'react';\nimport './master.css';\n\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min) ) + min;\n}\n\nfunction isVowel(char) {\n  /*\n  thx https://stackoverflow.com/a/5488098/14257952\n  */\n  return ['a', 'e', 'i', 'o', 'u'].indexOf(char.toLowerCase()) !== -1\n}\n\nfunction Ship(props) {\n  const enemyImgUrl = 'https://live.staticflickr.com/65535/50724769872_da72a3fd7c_t.jpg';\n  const allyImgUrl = 'https://live.staticflickr.com/65535/50724684336_aaa14d5649_t.jpg';\n\n  if (!props.isAlly && props.isAlive) {  // is living enemy\n    return (\n      // enemy ships have lasers below them\n      <div className=\"ship\">\n        <img\n          src={ props.isAlly ? allyImgUrl : enemyImgUrl }\n        />\n        <Laser isAlly={false} laserState={props.state} />\n      </div>\n    );  \n  } else if (props.isAlive === true) {  // is living ally\n    return (\n      <div className=\"ship\">\n        <Laser isAlly={true} laserState={props.state} />\n        <img\n          src={ props.isAlly ? allyImgUrl : enemyImgUrl }\n        />\n      </div>\n    );\n  } else {  // ship has been destroyed\n    // render an empty div with the ship's size\n    return (\n      <div className=\"ship\"></div>\n    )\n  }\n}\n\nfunction Laser(props) {  \n  // url variables\n  const allyChargingLaserUrl = 'https://live.staticflickr.com/65535/50723947808_35ba1cd9e7_o.png';\n  const allyFiringLaserUrl = 'https://live.staticflickr.com/65535/50724684431_e854d32aa9_o.png';\n  const enemyChargingLaserUrl = 'https://live.staticflickr.com/65535/50724684381_4ca6f500da_t.jpg';\n  const enemyFiringLaserUrl = 'https://live.staticflickr.com/65535/50723947768_2ab5054c24_t.jpg';\n\n  let laserState = props.laserState;\n  const isAlly = props.isAlly;\n  let imageSource;\n  \n  // decide which image to use\n  if (laserState === 'charging') {\n    if (isAlly) {\n      imageSource = allyChargingLaserUrl;\n    } else {\n      imageSource = enemyChargingLaserUrl;\n    }\n  } else if (laserState === 'firing') {\n    if (isAlly) {\n      imageSource = allyFiringLaserUrl;\n    } else {\n      imageSource = enemyFiringLaserUrl;\n    }\n  } else {  // laserState is idle\n    return (\n      <div className=\"laser\"></div>  // empty space with the appropriate width\n    );\n  }\n  \n  // laser isn't idle, so return the charging or firing image\n  return (\n    <img src={imageSource} className=\"laser\" />\n  );    \n}\n\nfunction ShipRow(props) {\n  const shipRow = Object.values(props.ships).map((ship) => \n    <Ship isAlly={ship.isAlly()} isAlive={ship.isAlive()} state={ship.getState()} key={ship.getId()} />\n  );\n\n  return (\n      <ul className=\"game-row\">{shipRow}</ul>\n  );\n}\n\nfunction OutputArea(props) {\n    // make char array from input string\n    const outputString = props.output;\n    const outputChars = Array.from(outputString);\n\n    // prepare a generator of IDs for key prop\n    const idGenerator = props.reactKeys.values();\n    const outputCharPs = outputChars.map((char, index) => \n      <div column={index} key={idGenerator.next().value} >{char}</div>\n    );\n    const keys = props.outputCharKeys;\n  \n    return (\n      <div className=\"output-container\">\n        <ul className=\"game-text game-row\">{outputCharPs}</ul>\n      </div>\n    );\n}\n\nclass InputArea extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(event) {\n    this.props.onInputChange(event.target.value);\n  }\n  \n  render() {\n    return (\n      <form className=\"input-container game-text-container flex-container\">\n        <input\n          type=\"text\"\n          value={this.props.input}\n          className=\"input-box game-text\"\n          onChange={this.handleChange} />\n      </form>\n    );    \n  }\n}\n\nfunction * infiniteShipIdGenerator() {\n  let idHalf = 0;\n  while(true) {\n    yield 'ship' + (idHalf++).toString();\n  }\n}\n\nclass ShipObject {\n  constructor(isAlly, laneNumber) {\n    this.alive = true;\n    this.state = 'idle';\n    this.lane = laneNumber;\n    this.ally = isAlly;\n\n    const idPrefix = isAlly ? 'ally' : 'enemy';\n    this.id = idPrefix + laneNumber.toString();\n  }\n\n  getState() {\n    return this.state;\n  }\n\n  getId() {\n    return this.id;\n  }\n\n  getLane() {\n    return this.lane;\n  }\n\n  isAlly() {\n    return this.ally;\n  }\n\n  isAlive() {\n    return this.alive;\n  }\n\n  destroy() {\n    this.alive = false;\n  }\n\n  print() {\n    console.log('\\tid:', this.getId());\n    console.log('\\tisAlly:', this.isAlly());\n    console.log('\\tlane:', this.getLane());\n    console.log('\\tstate:', this.getState());\n    console.log('\\talive:', this.isAlive());\n  }\n\n  advanceState() {\n    if (this.state === 'idle') {\n      this.state = 'charging';\n    } else if (this.state === 'charging') {\n      this.state = 'firing';\n    } else {\n      this.state = 'idle';\n    }\n\n    return this.state;\n  }\n\n  retire() {\n    this.state = 'retired';\n  }\n}\n\nfunction getLaneFromShipId(shipId, isAlly) {\n  /*\n  takes a shipId string and optional bool isAlly for efficiency; returns the int lane number\n  */\n  // if allegiance isn't known; get it by parsing the ID\n  if (typeof isAlly !== 'boolean') {\n    isAlly = shipId.includes('ally') ? true : shipId.includes('enemy') ? false : 'ERROR';\n\n    if (isAlly === 'ERROR') {\n      console.log('Error parsing ship ID:', shipId);\n      return\n    }\n  } \n\n  // get allegiance prefix and split the lane number off from the ID\n  const idPrefix = isAlly ? 'ally' : 'enemy';\n  const lane = shipId.split(idPrefix)[1];\n  return parseInt(lane);\n}\n\nfunction printObject(object) {\n  console.log('\\n\\t', 'type: ', typeof object);\n  for (const key in object) {\n    console.log('\\t', key, ':', object[key]);\n  }\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const maxColumns = 7;\n\n    this.maxColumns = maxColumns;\n    this.allLanes = Array.from(new Array(maxColumns).keys());\n    this.tickMs = 8000;  // Ticks every 10 seconds. Affects how long player has to type a new word\n    this.laserFireMs = Math.floor(this.tickMs / this.tickMs * 1000);  // MUST be shorter than tickMs. Affects sfx and delay to remove beam img\n    this.isAtGameEnd = false;\n\n    this.state = this.getInitialState();\n\n    this.handleInputChange = this.handleInputChange.bind(this);\n    this.tick = this.tick.bind(this);\n    this.advanceShipState = this.advanceShipState.bind(this);\n    this.fireAllChargingShips = this.fireAllChargingShips.bind(this);\n    this.getLetterInLane = this.getLetterInLane.bind(this);\n    this.projectLaserTarget = this.projectLaserTarget.bind(this);\n    this.laneToId = this.laneToId.bind(this);\n    this.destroyShip = this.destroyShip.bind(this);\n    this.getOppositeShip = this.getOppositeShip.bind(this);\n    this.fireLaser = this.fireLaser.bind(this);\n    this.haltLaser = this.haltLaser.bind(this);\n    this.checkEndGame = this.checkEndGame.bind(this);\n    this.getInitialState = this.getInitialState.bind(this);\n    this.reinitializeState = this.reinitializeState.bind(this);\n    this.replayPrompt = this.replayPrompt.bind(this);\n  }\n  \n  getInitialState() {\n    /*\n    returns an object with spankin-new versions of the variables used in state\n    */\n    // track ship objects, keyed by ship ID\n    this.initialAllyShips = {};\n    this.initialEnemyShips = {};\n    for (const lane of this.allLanes.values()) {\n      // add an ally ship\n      let newAlly = new ShipObject(true, lane);  // TODO: can use const?\n      this.initialAllyShips[newAlly.getId()] = newAlly;\n\n      // add an enemy ship\n      let newEnemy = new ShipObject(false, lane);  // TODO: can use const?\n      this.initialEnemyShips[newEnemy.getId()] = newEnemy;\n    }\n\n    // track ID number of each ship in a given state, for convenience and efficiency elsewhere. Updated by advanceShipState\n    this.initialAllyShipStates = {\n        firingShips: [],\n        chargingShips: [],\n        idleShips: Array.from(Object.keys(this.initialAllyShips))  // keyed by ID\n    };\n\n    this.initialEnemyShipStates = {\n        firingShips: [],\n        chargingShips: [],\n        idleShips: Array.from(Object.keys(this.initialEnemyShips))  // keyed by ID\n    };\n\n    return {\n      input: 'begin',\n      allyShips: this.initialAllyShips,\n      enemyShips: this.initialEnemyShips,\n      allyShipStates: this.initialAllyShipStates,\n      enemyShipStates: this.initialEnemyShipStates\n    };\n  }\n\n  reinitializeState() {\n    /*\n    reinitializes state variables\n    */\n    this.setState(this.getInitialState());\n  }\n\n  advanceShipState(shipId) {\n    // param: shipId: id of the ship object to be updated\n    // calls the ship object's advanceState and updates both the Game's ship object and lane state lists\n\n    // get allegiance-specific variables\n    let ship;\n    let laneStateArray;\n    let shipObjects;\n\n    if (shipId.includes('ally')) {  // if it's an ally ship\n      ship = this.state.allyShips[shipId];\n      laneStateArray = 'allyShipStates';\n      shipObjects = 'allyShips';\n    } else {  // it's an enemy ship\n      ship = this.state.enemyShips[shipId];\n      laneStateArray = 'enemyShipStates';\n      shipObjects = 'enemyShips';\n    }\n\n    // get convenience variables\n    const shipState = ship.getState();\n\n    /*\n    ======================== \n    Update ship object state array \n    ======================== \n    */\n    let newShipObjects = {...this.state[shipObjects]};\n    newShipObjects[shipId].advanceState();\n    this.setState({ [shipObjects]: newShipObjects });\n\n    /*\n    ======================== \n    Update lane state arrays \n    ======================== \n    */\n    // find which lane state arrays to update\n    let newStateGroup;\n    let oldStateGroup;\n\n    if (shipState === 'idle') {\n      oldStateGroup = 'idleShips';\n      newStateGroup = 'chargingShips';\n    } else if (shipState === 'charging') {\n      oldStateGroup = 'chargingShips';\n      newStateGroup = 'firingShips';\n    } else {\n      oldStateGroup = 'firingShips';\n      newStateGroup = 'idleShips';\n    }\n\n    // now we know which lane state array to remove from, so get the index of this ship\n    const removalIndex = this.state[laneStateArray][oldStateGroup].indexOf(shipId);\n\n    // make copies of lane state arrays\n    let newStateGroupArray = this.state[laneStateArray][newStateGroup];\n    let oldStateGroupArray = this.state[laneStateArray][oldStateGroup];\n\n    // make the state advance changes to the copy arrays\n    newStateGroupArray.push(shipId);\n    oldStateGroupArray.splice(removalIndex, 1);\n\n    // set the Game state by replacing lane state arrays with the updated copies\n    this.setState({ [[laneStateArray][newStateGroup]]: newStateGroupArray });\n    this.setState({ [[laneStateArray][oldStateGroup]]: oldStateGroupArray });\n  }\n\n  getLetterInLane(lane) {\n    /*\n    returns the string letter in a given int lane\n    */\n    // validate given lane\n    if (typeof lane !== 'number') {\n      console.log('Error: expected lane to be type number, but got', typeof lane);\n      return;\n    } else if (lane >= this.allLanes.length || lane < 0) {\n      console.log('Error: out of bounds lane given to getLetterInLane');\n    }\n\n    // get the letter\n    const letter = this.state.input[lane];\n    return letter;\n  }\n\n  getOppositeShip(lane, isAlly) {\n    /*\n    takes an int lane and bool isAlly; returns a reference to the other ship in its lane\n    */\n    const oppositeShipId = this.laneToId(lane, !isAlly);\n    const oppositeGroup = isAlly ? 'enemyShips' : 'allyShips';\n    const oppositeShip = this.state[oppositeGroup][oppositeShipId];\n\n    return oppositeShip;\n  }\n\n  projectLaserTarget(lane, isAlly) {\n    /*\n    takes an int lane and bool isAlly; returns a string showing the first thing it collides with\n    */\n    // collides with consonant?\n    const letter = this.getLetterInLane(lane)\n    if (letter && ! isVowel(letter)) {\n      return 'consonant';\n    }\n\n    // collides with other's simultaneously fired laser?\n    const oppositeShip = this.getOppositeShip(lane, isAlly);\n    if (oppositeShip.state === 'firing') {\n      return 'otherBeam';\n    }\n\n    // collides with enemy ship?\n    if (oppositeShip.isAlive()) {\n      return 'otherShip';\n    }\n\n    // passes through the lane with no collision?\n    return 'empty';\n  }\n\n  haltLaser(ship) {\n    /*\n    takes a reference to a ship object and disables its laser \n      by removing it from the pool of idle or charging lasers\n    */\n    // get allegiance-specific array\n    let laneStateArray;\n    if (ship.isAlly()) {\n      laneStateArray = 'allyShipStates';\n    } else {\n      laneStateArray = 'enemyShipStates';\n    }\n\n    // get state-specific array\n    let oldStateGroup;\n    if (ship.getState() === 'idle') {\n      oldStateGroup = 'idleShips';\n    } else if (ship.getState() === 'charging') {\n      oldStateGroup = 'chargingShips';\n    } else {\n      oldStateGroup = 'firingShips';\n    }\n\n    // now we know which lane state array to remove from, so get the index of this ship\n    const removalIndex = this.state[laneStateArray][oldStateGroup].indexOf(ship.getId());\n\n    // make copies of lane state arrays\n    let oldStateGroupArray = this.state[laneStateArray][oldStateGroup];\n\n    // change the copy array\n    oldStateGroupArray.splice(removalIndex, 1);\n\n    // set the Game state by replacing lane state array with the updated copy\n    this.setState({ [[laneStateArray][oldStateGroup]]: oldStateGroupArray });\n  }\n\n  replayPrompt() {\n    // check for end of game\n    const endGameCondition = this.checkEndGame();\n    if (endGameCondition) {\n      // stop the main loop; game is finished\n      clearInterval(this.timerID);\n  \n      // check for win/lose\n      let resultMessage;\n      if (endGameCondition === 'win') {\n        resultMessage = 'Win!';\n      } else if (endGameCondition === 'lose') {\n        resultMessage = 'It\\'s ok\\, try again!';\n      } else if (endGameCondition === 'tie') {\n        resultMessage = 'Tie, pretty good.';\n      }\n      if (this.isAtGameEnd === false) {\n        this.isAtGameEnd = true;\n\n        const input = prompt(resultMessage + ' Press y to play again');\n\n        if (input === 'y') {\n          window.location = 'https://gelafin.github.io/laser-lanes/';  // temp, just reload the page to reset\n\n          /* OPTION B reinitializing the state vars works 100%, but there are bugs afterwards. Had \"isGameRestarting\" returns up to tick() and returned before setState(), but the new tick() just used some of the old state anyway\n          this.reinitializeState();\n        \n          // begin main game loop\n          this.timerID = setInterval(\n            () => this.tick(),\n            this.tickMs\n          );\n          */\n        }\n      }\n    }\n  }\n\n  destroyShip(ship) {\n    /*\n    takes a reference to a ship object and destroys that ship\n    */\n    this.sfx.explosion.play().catch(()=>{console.log('\\tERROR: explosion audio play() promise rejected. Click into the text box--or else this is localhost');});\n\n    // set .isAlive to false so ship remains as a tombstone\n    ship.destroy();\n\n    // disable its laser\n    this.haltLaser(ship);\n  }\n\n  laneToId(lane, isAlly) {\n    /**/\n    return isAlly ? 'ally' + lane : 'enemy' + lane;\n  }\n\n  fireLaser(shipObject) {\n    /*\n    takes a *firing* ship object and fires the laser, hitting whatever is first in its lane\n    if a ship is hit, that ship is destoyed, and the victorious ship's laser is retired (disabled)\n    */\n    // prepare convenience variables\n    const shipId = shipObject.getId();\n    const lane = shipObject.getLane();\n    const isAlly = shipObject.isAlly();\n\n    // determine laser target\n    const target = this.projectLaserTarget(lane, isAlly);\n    let disabledLaser = false;\n\n    // process consequences of laser hitting the target\n    if (target === 'consonant') {\n      // blocked by consonant\n    } else if (target === 'empty') {\n      // passes through an empty lane\n    } else if (target === 'otherShip' || target === 'otherBeam') {\n      // destroy other ship\n      const oppositeShip = this.getOppositeShip(lane, isAlly);\n      this.destroyShip(oppositeShip);\n\n      disabledLaser = true;\n    }\n\n    // play the sound effect\n    this.sfx.firingLaser.play().catch(()=>{console.log('\\tERROR: firingLaser audio play() promise rejected. Click into the text box--or else this is localhost');});\n\n    // done firing the laser; delay resetting state to idle for a few seconds to let player see it was fired\n    setTimeout(() => {\n      if (!disabledLaser) {\n        console.log('\\t\\tsetting it back to idle');\n        this.advanceShipState(shipId);\n      } else {\n        console.log('\\t\\tretiring it from idle ships now');\n        this.haltLaser(shipObject);\n  \n        // update the object in props for the children\n        // get allegiance-specific variables\n        let shipObjects;\n        if (shipId.includes('ally')) {  // if it's an ally ship\n          shipObjects = 'allyShips';\n        } else {  // it's an enemy ship\n          shipObjects = 'enemyShips';\n        }\n        /*\n        ======================== \n        Update ship object state array \n        ======================== \n        */\n        let newShipObjects = {...this.state[shipObjects]};\n        newShipObjects[shipId].retire();\n        this.setState({ [shipObjects]: newShipObjects });\n      }\n    }, this.laserFireMs);\n  }\n\n  fireAllChargingShips() {\n    /* \n    advances states of all charging ships to firing and processes consequences of laser strikes\n    */\n    for (const lane of this.allLanes) {\n      const allyId = this.laneToId(lane, true);\n      const enemyId = this.laneToId(lane, false);\n      const allyShip = this.state.allyShips[allyId];\n      const enemyShip = this.state.enemyShips[enemyId];\n      \n      if (allyShip.getState() !== 'charging' && enemyShip.getState() !== 'charging') {\n        continue;  // nothing to do here; neither ship is charging!\n      } else if (allyShip.getState() === 'charging' && enemyShip.getState() !== 'charging') {\n        // only ally is charging\n\n        // advance state to firing\n        this.advanceShipState(allyId);\n        this.fireLaser(allyShip);\n      } else if (enemyShip.getState() === 'charging' && allyShip.getState() !== 'charging') {\n        // only enemy is charging\n\n        // advance state to firing\n        this.advanceShipState(enemyId);\n        this.fireLaser(enemyShip);\n\n      } else {\n        // process both; laser collision\n        this.advanceShipState(allyId);  // advance state to firing\n        this.advanceShipState(enemyId);  // advance state to firing\n        this.fireLaser(allyShip);\n        this.fireLaser(enemyShip);\n      }\n    }\n  }\n\n  checkEndGame() {\n    /*\n    checks for win or loss; returns 'win' or 'lose' if game is over or else null\n    */\n    // if all allies (or enemies, can check either) have a dead opposite ship, \n    // count living allies vs living enemies and decide result\n    let allyCount = 0;\n    let enemyCount = 0;\n    for (const lane of this.allLanes) {\n      const allyId = this.laneToId(lane, true);\n      const enemyId = this.laneToId(lane, false);\n      const allyShip = this.state.allyShips[allyId];\n      const enemyShip = this.state.enemyShips[enemyId];\n\n      // if any lane still has two living ships, game is not over yet\n      if (allyShip.isAlive() && enemyShip.isAlive()) {\n        return null;\n      }\n\n      // keep a count of living allies\n      if (allyShip.isAlive()) {\n        allyCount++;\n      }\n\n      // keep a count of living enemies\n      if (enemyShip.isAlive()) {\n        enemyCount++;\n      }\n    }\n\n    // the game is over. Count ships to decide winner\n    if (allyCount > enemyCount) {\n      return 'win';\n    } else if (allyCount < enemyCount) {\n      return 'lose';\n    } else {\n      return 'tie';\n    }\n  }\n\n  tick() {\n    console.log('----- ticking -----');\n    \n    this.fireAllChargingShips();\n    \n    this.replayPrompt();\n\n    if (this.isAtGameEnd === true) {\n      return;\n    }\n\n    this.setState((state) => {\n\n      // advance the state of 1 random idle laser per side to charging\n      // get random indices for lane states arrays\n      const randomIdleAllyIndex = randomInt(0, state.allyShipStates.idleShips.length);\n      const randomIdleEnemyIndex = randomInt(0, state.enemyShipStates.idleShips.length);\n\n      // use those indices to get a random idle ship's ID\n      const randomIdleAllyId = state.allyShipStates.idleShips[randomIdleAllyIndex];\n      const randomIdleEnemyId = state.enemyShipStates.idleShips[randomIdleEnemyIndex];\n\n      if (typeof randomIdleAllyId === 'undefined' || typeof randomIdleEnemyId === 'undefined'  ) {\n        return;  // for the final tick, when the delayed destroyShip() hasn't been called yet\n      }\n      \n      if (state.allyShips[randomIdleAllyId].isAlive() === false) {\n        console.log('********** charging' + randomIdleAllyId + ' even though it\\'s dead');\n      } else if (state.enemyShips[randomIdleEnemyId].isAlive() === false) {\n        console.log('********** charging' + randomIdleAllyId + ' even though it\\'s dead');\n      } else {\n        console.log('***** charging' + randomIdleAllyId + ' and ' + randomIdleEnemyId);\n      }\n\n      // advance the states from idle to charging\n      this.advanceShipState(randomIdleAllyId);\n      this.advanceShipState(randomIdleEnemyId);\n\n      // play charging sound effect\n      this.sfx.chargingLaser.play().catch(()=>{console.log('\\tERROR: chargingLaser audio play() promise rejected. Click into the text box--or else this is localhost');});\n\n    }, ()=>{console.log(' > finished tick setState! Best to call advanceShipState here');});\n  }\n  \n  componentDidMount() {\n    // popup with start button (TODO: make it a real popup)\n    alert('Laser Lanes\\n\\n' + 'Lasers fire automatically every ' + Math.floor(this.tickMs / 1000) + ' seconds. Lasers are blocked by consonants but pass through vowels, so please type words that will win');\n\n    // begin main game loop\n    this.timerID = setInterval(\n      () => this.tick(),\n      this.tickMs\n    );\n\n    // load sfx (should only load these once, then play them as needed)\n    this.sfx = {\n      explosion: new Audio('./sfx/explosion.mp3'),\n      chargingLaser: new Audio('./sfx/charging_laser.mp3'),\n      firingLaser: new Audio('./sfx/firing_laser.mp3'),\n    };\n\n    // balance audio\n    this.sfx.explosion.volume = 0.1;\n    this.sfx.chargingLaser.volume = 0.1;\n  }\n  \n  componentWillUnmount() {\n    if (this.timerID) {\n      clearInterval(this.timerID);\n    }\n  }\n  \n  handleInputChange(value) {\n    this.setState({input: value});\n    console.log('set input to ', value);\n  }\n  \n  render() {\n    const MAX_COLUMNS = this.maxColumns;\n\n    // make keys required by React for lists of elements. TODO: use something more unlimited, since player can type outside of play area. Else, just restrict typing and give up on validating words\n    const outputCharKeys = new Array(MAX_COLUMNS).fill(0).map((element, index) => index);\n\n    return (\n      <div className=\"game-container flex-container\">\n\n        <div className=\"visuals-container\">\n          <ShipRow ships={this.state.enemyShips} />\n          <OutputArea output={this.state.input} reactKeys={outputCharKeys} />\n          <ShipRow ships={this.state.allyShips} />\n        </div>\n\n        <div>\n          <InputArea input={this.state.input} onInputChange={this.handleInputChange} />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Game;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Game from './Game';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}